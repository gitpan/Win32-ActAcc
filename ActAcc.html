<HTML>
<HEAD>
<TITLE>Win32::ActAcc - `Active Accessibility' for task automation, GUI testing</TITLE>
<LINK REV="made" HREF="mailto:">
</HEAD>

<BODY>

<A NAME="__index__"></A>
<!-- INDEX BEGIN -->

<UL>

	<LI><A HREF="#name">NAME</A></LI>
	<LI><A HREF="#synopsis">SYNOPSIS</A></LI>
	<LI><A HREF="#description">DESCRIPTION</A></LI>
	<UL>

		<LI><A HREF="#what does it all mean">What does it all mean?</A></LI>
		<LI><A HREF="#samples">Samples</A></LI>
		<LI><A HREF="#active accessibility client api">Active Accessibility client API</A></LI>
		<UL>

			<LI><A HREF="#desktop">Desktop</A></LI>
			<LI><A HREF="#accessibleobjectfromwindow">AccessibleObjectFromWindow</A></LI>
			<LI><A HREF="#accessibleobjectfrompoint">AccessibleObjectFromPoint</A></LI>
			<LI><A HREF="#click">click</A></LI>
			<LI><A HREF="#getroletext">GetRoleText</A></LI>
			<LI><A HREF="#getstatetext">GetStateText</A></LI>
			<LI><A HREF="#getstatetextcomposite">GetStateTextComposite</A></LI>
			<LI><A HREF="#stateconstantname">StateConstantName</A></LI>
			<LI><A HREF="#objectidconstantname">ObjectIdConstantName</A></LI>
			<LI><A HREF="#nav">nav</A></LI>
			<LI><A HREF="#menupick">menuPick</A></LI>
			<LI><A HREF="#childid_self and lots of other constants">CHILDID_SELF and lots of other constants</A></LI>
			<UL>

				<LI><A HREF="#event constants">EVENT constants</A></LI>
				<LI><A HREF="#objid constants">OBJID constants</A></LI>
				<LI><A HREF="#state constants">STATE constants</A></LI>
				<LI><A HREF="#role constants">ROLE constants</A></LI>
				<LI><A HREF="#selflag constants">SELFLAG constants</A></LI>
				<LI><A HREF="#navdir constants">NAVDIR constants</A></LI>
			</UL>

		</UL>

		<LI><A HREF="#win32::actacc::ao">Win32::ActAcc::AO</A></LI>
		<UL>

			<LI><A HREF="#comparing accessible objects">Comparing Accessible Objects</A></LI>
			<LI><A HREF="#describe">describe</A></LI>
			<LI><A HREF="#windowfromaccessibleobject">WindowFromAccessibleObject</A></LI>
			<LI><A HREF="#get_accname">get_accName</A></LI>
			<LI><A HREF="#get_accrole">get_accRole</A></LI>
			<LI><A HREF="#accessiblechildren">AccessibleChildren</A></LI>
			<LI><A HREF="#navigablechildren">NavigableChildren</A></LI>
			<LI><A HREF="#get_accparent">get_accParent</A></LI>
			<LI><A HREF="#get_accstate">get_accState</A></LI>
			<LI><A HREF="#get_accvalue">get_accValue</A></LI>
			<LI><A HREF="#acclocation">accLocation</A></LI>
			<LI><A HREF="#accnavigate">accNavigate</A></LI>
			<LI><A HREF="#get_accdescription">get_accDescription</A></LI>
			<LI><A HREF="#get_acchelp">get_accHelp</A></LI>
			<LI><A HREF="#get_accdefaultaction">get_accDefaultAction</A></LI>
			<LI><A HREF="#get_acckeyboardshortcut">get_accKeyboardShortcut</A></LI>
			<LI><A HREF="#get_accchildcount">get_accChildCount</A></LI>
			<LI><A HREF="#get_accchild">get_accChild</A></LI>
			<LI><A HREF="#get_accfocus">get_accFocus</A></LI>
			<LI><A HREF="#accdodefaultaction">accDoDefaultAction</A></LI>
			<LI><A HREF="#get_itemid">get_itemID</A></LI>
			<LI><A HREF="#accselect">accSelect</A></LI>
			<LI><A HREF="#click">click</A></LI>
			<LI><A HREF="#finddescendant">findDescendant</A></LI>
			<LI><A HREF="#release">Release</A></LI>
		</UL>

		<LI><A HREF="#winevents">WinEvents</A></LI>
		<UL>

			<LI><A HREF="#createeventmonitor">createEventMonitor</A></LI>
			<LI><A HREF="#eventmonitor">EventMonitor</A></LI>
			<UL>

				<LI><A HREF="#waitforevent">waitForEvent</A></LI>
				<LI><A HREF="#getevent">getEvent</A></LI>
				<LI><A HREF="#clear">clear</A></LI>
				<LI><A HREF="#synch">synch</A></LI>
				<LI><A HREF="#isactive">isActive</A></LI>
				<LI><A HREF="#activate">activate</A></LI>
				<LI><A HREF="#geteventcount">getEventCount</A></LI>
				<LI><A HREF="#debug_spin">debug_spin</A></LI>
			</UL>

			<LI><A HREF="#win32::actacc::event">Win32::ActAcc::Event</A></LI>
			<UL>

				<LI><A HREF="#getao">getAO</A></LI>
				<LI><A HREF="#evdescribe">evDescribe</A></LI>
			</UL>

			<LI><A HREF="#eventconstantname">EventConstantName</A></LI>
			<LI><A HREF="#accessibleobjectfromevent">AccessibleObjectFromEvent</A></LI>
			<LI><A HREF="#event details">Event Details</A></LI>
		</UL>

		<LI><A HREF="#tools">Tools</A></LI>
		<UL>

			<LI><A HREF="#aadigger.pl">aaDigger.pl</A></LI>
			<LI><A HREF="#aaevents.pl">aaEvents.pl</A></LI>
			<LI><A HREF="#aawhereami.pl">aaWhereAmI.pl</A></LI>
		</UL>

	</UL>

	<LI><A HREF="#bugs, limitations, and shortcomings">BUGS, LIMITATIONS, AND SHORTCOMINGS</A></LI>
	<LI><A HREF="#installation">INSTALLATION</A></LI>
	<UL>

		<LI><A HREF="#installation from source code">Installation from source code</A></LI>
		<LI><A HREF="#installation for activeperl users (ppm)">Installation for ActivePerl users (PPM)</A></LI>
		<LI><A HREF="#files installed">Files Installed</A></LI>
	</UL>

	<LI><A HREF="#copyright">COPYRIGHT</A></LI>
	<LI><A HREF="#author">AUTHOR</A></LI>
	<LI><A HREF="#see also">SEE ALSO</A></LI>
</UL>
<!-- INDEX END -->

<HR>
<P>
<H1><A NAME="name">NAME</A></H1>
<P>Win32::ActAcc - `Active Accessibility' for task automation, GUI testing</P>
<P>
<HR>
<H1><A NAME="synopsis">SYNOPSIS</A></H1>
<P>Win32::ActAcc gives Perl scripts free 
run of the Active Accessibility client API; IAccessible; and ``WinEvents''.</P>
<P>Active Accessibility lets Perl scripts see what's on the screen, even
when programs use ``custom controls'', lightweight (drawn) controls 
that are not technically windows, and the like:  VB for example.</P>
<P>You'll want to additionally use Win32::GuiTest, and other Win32 modules,
if you want your script to click, type, manipulate the clipboard, etc.</P>
<PRE>
 use Win32::OLE;
 use Win32::ActAcc;
 Win32::OLE-&gt;Initialize();</PRE>
<PRE>
 # Start navigating window tree at its root -- the Desktop.
 $accObj = Desktop();
 @childAccObjs = $accObj-&gt;AccessibleChildren();</PRE>
<PRE>
 $name = $accObj-&gt;get_accName();
 $rolename = Win32::ActAcc::GetRoleText($accObj-&gt;get_accRole());</PRE>
<P>
<HR>
<H1><A NAME="description">DESCRIPTION</A></H1>
<P>
<H2><A NAME="what does it all mean">What does it all mean?</A></H2>
<P>Win32::ActAcc broadly parallels the Active Accessibility spec.</P>
<UL>
<LI>
You obtain accessible objects and event streams using the Active Accessibility API, via <EM>Win32::ActAcc</EM>.
<P></P>
<LI>
You manipulate an accessible object using IAccessible, via <EM>Win32::AO</EM>.
<P></P></UL>
<P>This pod doesn't duplicate the Active Accessibility spec.  See <A HREF="#see also">SEE ALSO</A>.</P>
<P><STRONG>Note to folks already acquainted with Active Accessibility:</STRONG> 
If you've programmed with Active Accessibility in C, you know first-hand that Active Accessibility was
designed with the convenience of the <EM>server</EM> programmer in mind, and little
regard for the happiness of the <EM>client</EM>.  Clients often need not one, but two 
handles to refer to an accessible GUI feature - an IAccessible* and a ``child ID''.  
Win32::ActAcc wraps that pair of 
handles in a single Perl object representing each accessible GUI feature:  Win32::AO, for Accessible Object.</P>
<P>This manual makes the following notational innovations:</P>
<OL>
<LI>
We preserve the name Microsoft chose for the methods and functions that
come more or less straight out of the Active Accessibility SDK.
<P></P>
<LI>
Active Accessibility has some minor imperfections.  Of course, Win32::ActAcc also has imperfections.
To aid the reader in distinguishing the two, we have taken the liberty of calling out
some ``Active Accessibility weirdnesses'' as such.
<P></P></OL>
<P>
<H2><A NAME="samples">Samples</A></H2>
<P><STRONG>aaDigger.pl</STRONG> shows how to traverse the tree of accessible objects.</P>
<P><STRONG>aaEvents.pl</STRONG> shows you the WinEvents that reflect what you're doing with the GUI.</P>
<P><STRONG>aaWhereAmI.pl</STRONG> shows how to link a pixel location with its accessible object.</P>
<P>eg/<STRONG>aaAIMEliza.pl</STRONG>, at the risk of getting ridiculous, shows how to 
make Chatbot::Eliza respond to your incoming AOL Instant Messages.  AIM is an 
application whose GUI is not made of standard controls, so this is an example
of something you could not do (without constantly doing a File-Save As)
with tools based on the Win32 API, window-classes and window-messages.</P>
<P>See under <A HREF="#tools">Tools</A> for more about aaDigger, aaEvents, and aaWhereAmI.</P>
<P>
<H2><A NAME="active accessibility client api">Active Accessibility client API</A></H2>
<P>The client API exposes jumping-off points like Desktop and AccessibleObjectFromWindow,
and ``helper functions'' like GetRoleText.</P>
<P>If this is your first reading, you may want to read about 
Desktop and AccessibleObjectFromWindow in this section,
then skip to <A HREF="#win32::actacc::ao">Win32::ActAcc::AO</A>.</P>
<P>
<H3><A NAME="desktop">Desktop</A></H3>
<P>Obtain an ``accessible object'' representing the desktop, so you can call the object's 
Active Accessibility methods:</P>
<PRE>
 $accObj = Desktop();
 die unless 'Win32::ActAcc::AO' eq ref($accObj);</PRE>
<P>The Desktop is a natural starting-point for traversing the tree of Accessible Objects.</P>
<P>Once you've got an accessible object, see <A HREF="#win32::actacc::ao">Win32::ActAcc::AO</A> on how to use it.</P>
<P>If you do not have a clear picture in mind of the accessible-object ``tree'' of 
which Desktop is the root, go try out the <A HREF="#aadigger.pl">aaDigger.pl</A> tool.</P>
<P>
<H3><A NAME="accessibleobjectfromwindow">AccessibleObjectFromWindow</A></H3>
<P>If you have an HWND, you can convert it to an Accessible Object with AccessibleObjectFromWindow:</P>
<PRE>
 $accObj = AccessibleObjectFromWindow($hwnd);
 die unless 'Win32::ActAcc::AO' eq ref($accObj);</PRE>
<P>AccessibleObjectFromWindow's optional second parameter defaults to OBJID_WINDOW.  
Win32::ActAcc defines all the OBJID constants for Perl.  (They come from WinAble.h.)
See <A HREF="#objid constants">OBJID constants</A>.</P>
<P>
<H3><A NAME="accessibleobjectfrompoint">AccessibleObjectFromPoint</A></H3>
<P>AccessibleObjectFromPoint checks the screen at the specified point and returns
an accessible object representing the interactive item at that location.</P>
<PRE>
 my $accObj = AccessibleObjectFromPoint($x, $y);</PRE>
<P>Speaking of ($x, $y), how do you figure out where the mouse is?  You can 
subscribe to the WinEvents stream and watch for mouse location-change events.
See sample aaEvents.pl to see how this works.</P>
<P>Not all ``accessible'' objects are in the Desktop-rooted hierarchy.  Therefore, 
AccessibleObjectFromPoint may be the only way to access some ``accessible'' objects.</P>
<P>
<H3><A NAME="click">click</A></H3>
<PRE>
 Win32::ActAcc::click($xpix, $ypix, \$eh);</PRE>
<P><CODE>click()</CODE> ``clicks'' somewhere on the screen, but first, it
activates the optional event monitor, so you can capture the consequences
of the click.  See <A HREF="#activate">activate</A> and <A HREF="#menupick">menuPick</A>.</P>
<P>You should use Win32::GuiTest for any extensive GUI manipulation.  Win32::ActAcc's ``click'' method is not 
as flexible.</P>
<P>
<H3><A NAME="getroletext">GetRoleText</A></H3>
<P>Returns localized name of a role-number.</P>
<PRE>
 my $chRole = Win32::ActAcc::GetRoleText($accObj-&gt;get_accRole());</PRE>
<P>
<H3><A NAME="getstatetext">GetStateText</A></H3>
<P>Returns localized name of a state-number.</P>
<PRE>
 my $statebit = Win32::ActAcc::STATE_SYSTEM_FOCUSED();
 my $statename = Win32::ActAcc::GetStateText($statebit);</PRE>
<P>Active Accessibility weirdness note:  States are <EM>combinations</EM>
of state-bits such as STATE_SYSTEM_FOCUSED (see <A HREF="#state constants">STATE constants</A>).  
GetStateText returns the name of 
only one of the bits that are set in the argument.
If you want a quick way to get the <EM>whole</EM> truth about 
<EM>all</EM> the bits that are set, call <A HREF="#getstatetextcomposite">GetStateTextComposite</A> instead.</P>
<P>
<H3><A NAME="getstatetextcomposite">GetStateTextComposite</A></H3>
<P>Returns a localized string of state texts, representing all of the turned-on state
bits in the argument.</P>
<PRE>
 $stateDesc = Win32::ActAcc::GetStateTextComposite( $accObj-&gt;get_accState() );</PRE>
<P>
<H3><A NAME="stateconstantname">StateConstantName</A></H3>
<P>Returns the C constant name for a state-bit defined in OleAcc.h (see <A HREF="#state constants">STATE constants</A>).</P>
<P>
<H3><A NAME="objectidconstantname">ObjectIdConstantName</A></H3>
<P>Returns the C constant name for an object ID defined in OleAcc.h.</P>
<P>
<H3><A NAME="nav">nav</A></H3>
<P>nav finds a child Accessible Object by following a path from a starting point.
The path specifies the name and/or role of each object along the path.</P>
<P>You can use nav to find the Start button.  Giving undef as the starting point makes
nav begin with the Desktop.</P>
<PRE>
 $btnStart = Win32::ActAcc::nav(Desktop(), [ &quot;{window}&quot;, &quot;{window}Start&quot;, &quot;{push button}Start&quot; ] );</PRE>
<P>nav is also useful finding a control on a dialog:</P>
<PRE>
 $accObjOk = Win32::ActAcc::nav($accObjDlg, [ &quot;OK&quot; ]);</PRE>
<P>
<H3><A NAME="menupick">menuPick</A></H3>
<P>menuPick traverses a menu (starting with a menu bar), making a list of choices.
Each choice is a regexp that must match one menu item.
Right before making the final choice, menuPick activates your event monitor,
so you can catch the consequences of the menu choice.</P>
<PRE>
 my $menubar = ...
 my $ehDlg = Win32::ActAcc::createEventMonitor(0);
 menuPick($menubar, +[ qr/Format/, qr/Font/ ], \$ehDlg);
 $ehDlg-&gt;waitForEvent(
   +{ 'event'=&gt;Win32::ActAcc::EVENT_SYSTEM_DIALOGSTART() });</PRE>
<P>(Note:  menuPick is still experimental.  It works with Notepad.)</P>
<P>
<H3><A NAME="childid_self and lots of other constants">CHILDID_SELF and lots of other constants</A></H3>
<P>Use Win32::ActAcc constants as though they were functions:</P>
<PRE>
 die unless (0 == Win32::ActAcc::CHILDID_SELF());</PRE>
<P>Win32::ActAcc provides the following Active Accessibility constants
in addition to CHILDID_SELF and CCHILDREN_FRAME:</P>
<P>
<H4><A NAME="event constants">EVENT constants</A></H4>
<font face="Arial Narrow" size="-1"><P>EVENT_SYSTEM_SOUND, EVENT_SYSTEM_ALERT, EVENT_SYSTEM_FOREGROUND, EVENT_SYSTEM_MENUSTART, EVENT_SYSTEM_MENUEND, EVENT_SYSTEM_MENUPOPUPSTART, EVENT_SYSTEM_MENUPOPUPEND, EVENT_SYSTEM_CAPTURESTART, EVENT_SYSTEM_CAPTUREEND, EVENT_SYSTEM_MOVESIZESTART, EVENT_SYSTEM_MOVESIZEEND, EVENT_SYSTEM_CONTEXTHELPSTART, EVENT_SYSTEM_CONTEXTHELPEND, EVENT_SYSTEM_DRAGDROPSTART, EVENT_SYSTEM_DRAGDROPEND, EVENT_SYSTEM_DIALOGSTART, EVENT_SYSTEM_DIALOGEND, EVENT_SYSTEM_SCROLLINGSTART, EVENT_SYSTEM_SCROLLINGEND, EVENT_SYSTEM_SWITCHSTART, EVENT_SYSTEM_SWITCHEND, EVENT_SYSTEM_MINIMIZESTART, EVENT_SYSTEM_MINIMIZEEND, EVENT_OBJECT_CREATE, EVENT_OBJECT_DESTROY, EVENT_OBJECT_SHOW, EVENT_OBJECT_HIDE, EVENT_OBJECT_REORDER, EVENT_OBJECT_FOCUS, EVENT_OBJECT_SELECTION, EVENT_OBJECT_SELECTIONADD, EVENT_OBJECT_SELECTIONREMOVE, EVENT_OBJECT_SELECTIONWITHIN, EVENT_OBJECT_STATECHANGE, EVENT_OBJECT_LOCATIONCHANGE, EVENT_OBJECT_NAMECHANGE, EVENT_OBJECT_DESCRIPTIONCHANGE, EVENT_OBJECT_VALUECHANGE, EVENT_OBJECT_PARENTCHANGE, EVENT_OBJECT_HELPCHANGE, EVENT_OBJECT_DEFACTIONCHANGE, EVENT_OBJECT_ACCELERATORCHANGE</P>
</font><P>
<H4><A NAME="objid constants">OBJID constants</A></H4>
<font face="Arial Narrow" size="-1"><P>OBJID_WINDOW, OBJID_SYSMENU, OBJID_TITLEBAR, OBJID_MENU, OBJID_CLIENT, OBJID_VSCROLL, OBJID_HSCROLL, OBJID_SIZEGRIP, OBJID_CARET, OBJID_CURSOR, OBJID_ALERT, OBJID_SOUND</P>
</font><P>
<H4><A NAME="state constants">STATE constants</A></H4>
<font face="Arial Narrow" size="-1"><P>STATE_SYSTEM_NORMAL, STATE_SYSTEM_UNAVAILABLE, STATE_SYSTEM_SELECTED, STATE_SYSTEM_FOCUSED, STATE_SYSTEM_PRESSED, STATE_SYSTEM_CHECKED, STATE_SYSTEM_MIXED, STATE_SYSTEM_INDETERMINATE, STATE_SYSTEM_READONLY, STATE_SYSTEM_HOTTRACKED, STATE_SYSTEM_DEFAULT, STATE_SYSTEM_EXPANDED, STATE_SYSTEM_COLLAPSED, STATE_SYSTEM_BUSY, STATE_SYSTEM_FLOATING, STATE_SYSTEM_MARQUEED, STATE_SYSTEM_ANIMATED, STATE_SYSTEM_INVISIBLE, STATE_SYSTEM_OFFSCREEN, STATE_SYSTEM_SIZEABLE, STATE_SYSTEM_MOVEABLE, STATE_SYSTEM_SELFVOICING, STATE_SYSTEM_FOCUSABLE, STATE_SYSTEM_SELECTABLE, STATE_SYSTEM_LINKED, STATE_SYSTEM_TRAVERSED, STATE_SYSTEM_MULTISELECTABLE, STATE_SYSTEM_EXTSELECTABLE, STATE_SYSTEM_ALERT_LOW, STATE_SYSTEM_ALERT_MEDIUM, STATE_SYSTEM_ALERT_HIGH, STATE_SYSTEM_PROTECTED, STATE_SYSTEM_VALID</P>
</font><P>
<H4><A NAME="role constants">ROLE constants</A></H4>
<font face="Arial Narrow" size="-1"><P>ROLE_SYSTEM_TITLEBAR, ROLE_SYSTEM_MENUBAR, ROLE_SYSTEM_SCROLLBAR, ROLE_SYSTEM_GRIP, ROLE_SYSTEM_SOUND, ROLE_SYSTEM_CURSOR, ROLE_SYSTEM_CARET, ROLE_SYSTEM_ALERT, ROLE_SYSTEM_WINDOW, ROLE_SYSTEM_CLIENT, ROLE_SYSTEM_MENUPOPUP, ROLE_SYSTEM_MENUITEM, ROLE_SYSTEM_TOOLTIP, ROLE_SYSTEM_APPLICATION, ROLE_SYSTEM_DOCUMENT, ROLE_SYSTEM_PANE, ROLE_SYSTEM_CHART, ROLE_SYSTEM_DIALOG, ROLE_SYSTEM_BORDER, ROLE_SYSTEM_GROUPING, ROLE_SYSTEM_SEPARATOR, ROLE_SYSTEM_TOOLBAR, ROLE_SYSTEM_STATUSBAR, ROLE_SYSTEM_TABLE, ROLE_SYSTEM_COLUMNHEADER, ROLE_SYSTEM_ROWHEADER, ROLE_SYSTEM_COLUMN, ROLE_SYSTEM_ROW, ROLE_SYSTEM_CELL, ROLE_SYSTEM_LINK, ROLE_SYSTEM_HELPBALLOON, ROLE_SYSTEM_CHARACTER, ROLE_SYSTEM_LIST, ROLE_SYSTEM_LISTITEM, ROLE_SYSTEM_OUTLINE, ROLE_SYSTEM_OUTLINEITEM, ROLE_SYSTEM_PAGETAB, ROLE_SYSTEM_PROPERTYPAGE, ROLE_SYSTEM_INDICATOR, ROLE_SYSTEM_GRAPHIC, ROLE_SYSTEM_STATICTEXT, ROLE_SYSTEM_TEXT, ROLE_SYSTEM_PUSHBUTTON, ROLE_SYSTEM_CHECKBUTTON, ROLE_SYSTEM_RADIOBUTTON, ROLE_SYSTEM_COMBOBOX, ROLE_SYSTEM_DROPLIST, ROLE_SYSTEM_PROGRESSBAR, ROLE_SYSTEM_DIAL, ROLE_SYSTEM_HOTKEYFIELD, ROLE_SYSTEM_SLIDER, ROLE_SYSTEM_SPINBUTTON, ROLE_SYSTEM_DIAGRAM, ROLE_SYSTEM_ANIMATION, ROLE_SYSTEM_EQUATION, ROLE_SYSTEM_BUTTONDROPDOWN, ROLE_SYSTEM_BUTTONMENU, ROLE_SYSTEM_BUTTONDROPDOWNGRID, ROLE_SYSTEM_WHITESPACE, ROLE_SYSTEM_PAGETABLIST, ROLE_SYSTEM_CLOCK</P>
</font><P>
<H4><A NAME="selflag constants">SELFLAG constants</A></H4>
<font face="Arial Narrow" size="-1"><P>SELFLAG_NONE, SELFLAG_TAKEFOCUS, SELFLAG_TAKESELECTION, SELFLAG_EXTENDSELECTION, SELFLAG_ADDSELECTION, SELFLAG_REMOVESELECTION, SELFLAG_VALID</P>
</font><P>
<H4><A NAME="navdir constants">NAVDIR constants</A></H4>
<font face="Arial Narrow" size="-1"><P>NAVDIR_MIN, NAVDIR_UP, NAVDIR_DOWN, NAVDIR_LEFT, NAVDIR_RIGHT, NAVDIR_NEXT, NAVDIR_PREVIOUS, NAVDIR_FIRSTCHILD, NAVDIR_LASTCHILD, NAVDIR_MAX</P>
</font><P>
<H2><A NAME="win32::actacc::ao">Win32::ActAcc::AO</A></H2>
<P>IAccessible methods are in the Win32::ActAcc::AO package, so you can use them the
object-oriented way.</P>
<P>
<H3><A NAME="comparing accessible objects">Comparing Accessible Objects</A></H3>
<P>AO's that map to HWNDs can be compared by getting their HWNDs and comparing those.  Since AO's without HWNDs cannot 
be compared, you will want to avoid planning algorithms that depend on comparing accessible objects.</P>
<PRE>
 $h1 = $ao1-&gt;WindowFromAccessibleObject();
 $h2 = $ao2-&gt;WindowFromAccessibleObject();
 if ($h1 == $h2) { ... }</PRE>
<P>You generally can't compare two AO objects directly because of the following weirdness.</P>
<P>Active Accessibility weirdness note:  The default Active Accessibility server helper 
built into Windows to represent standard controls 
returns a new object in response to any query.  If an Active Accessibility client requests the same accessible GUI 
feature several times, it gets several different IAccessible* pointers back.</P>
<P>Win32::ActAcc always uses the same
Perl object for any given IAccessible-and-childID pair, so if you have a stable
server (which you probably don't), you can take advantage in Perl.</P>
<P>
<H3><A NAME="describe">describe</A></H3>
<P>Produces human-readible (appropriate for debugging) description of an AO. 
Here's an example, with the fields labeled.</P>
<PRE>
 window:emacs: ActAcc.pod {sizeable+moveable+focusable,(4,44,1009,663),id=0,000402e2}
 ^      ^--title/text      ^-- 'state' bits            ^               ^--ID                   
 |                                                     |                    ^-- HWND
 +-role                                                +-(left,top,width,height)</PRE>
<P><CODE>describe()</CODE> isn't supposed to die.  If something goes wrong, it returns an 
incomplete or empty string.</P>
<PRE>
 print $accObj-&gt;describe();</PRE>
<P>If your script displays the results of <CODE>describe()</CODE> to its user, you
might also want to print out <CODE>describe_meta()</CODE> at least once.  It names
the fields.</P>
<PRE>
 print Win32::ActAcc::AO::describe_meta();</PRE>
<P>
<H3><A NAME="windowfromaccessibleobject">WindowFromAccessibleObject</A></H3>
<P>Reverses <A HREF="#accessibleobjectfromwindow">AccessibleObjectFromWindow</A>:</P>
<PRE>
 $hwnd = $accObj-&gt;WindowFromAccessibleObject();</PRE>
<P>If no HWND corresponds to the object, WindowFromAccessibleObject dies, so you might
want to run it inside an eval().</P>
<P>
<H3><A NAME="get_accname">get_accName</A></H3>
<P>Returns the 'name' property of the accessible object.  
For editable text and combo box objects, it appears 
this is the label Windows supposes the object has: it is usually 
identical to the text of the immediately-preceding text object.
For windows, this is the title.  For client areas, this is 
the same as the title of the enclosing window.</P>
<PRE>
 $name = $accObj-&gt;get_accName();</PRE>
<P>Returns undef if the object doesn't have this property.</P>
<P>
<H3><A NAME="get_accrole">get_accRole</A></H3>
<PRE>
 $role = $accObj-&gt;get_accRole();</PRE>
<P>Returns a number, probably one of the Active Accessibility ROLE_ constants
(see <A HREF="#role constants">ROLE Constants</A>).  You can convert the number
to a string with Win32::ActAcc::GetRoleText.
Returns undef if the object doesn't have this property.</P>
<P>
<H3><A NAME="accessiblechildren">AccessibleChildren</A></H3>
<PRE>
 @ch = $accObj-&gt;AccessibleChildren();</PRE>
<P>Returns a list of the accessible objects that are children
of $accObj.  By default it omits the invisible children:
the no-argument form of AccessibleChildren is short for</P>
<PRE>
 @ch = $accObj-&gt;AccessibleChildren(Win32::ActAcc::STATE_SYSTEM_INVISIBLE(), 0);</PRE>
<P>The first parameter is a bit mask with 1's for the bits
that matter as criteria, and the second parameter is the bit values
to find in each of the '1' positions in the mask.</P>
<P>To find only the invisible
children, you can use:</P>
<PRE>
 @ch = $accObj-&gt;AccessibleChildren(
    Win32::ActAcc::STATE_SYSTEM_INVISIBLE(), 
        Win32::ActAcc::STATE_SYSTEM_INVISIBLE());</PRE>
<P>which means that the INVISIBLE bit should be included in the comparison, and it must be 1.  
See <A HREF="#state constants">STATE constants</A>.</P>
<P>Active Accessibility weirdness note:  You will probably want to use <CODE>AccessibleChildren()</CODE> instead of 
<CODE>get_accChildCount()</CODE> and get_accChild().  AccessibleChildren probably calls those
and then improves the results.  But, AccessibleChildren frequently returns fewer
children than get_accChildCount says it should.</P>
<P>Active Accessibility weirdness note:  Some objects report 1 child with AccessibleChildren, yet 
accNavigate reveals more children.  You can work around this problem by calling
<A HREF="#navigablechildren">NavigableChildren</A> instead.  Note that NavigableChildren may have its own drawbacks.</P>
<P>In the Active Accessibility SDK, <CODE>AccessibleChildren()</CODE> is part of
the API, not part of IAccessible.</P>
<P>
<H3><A NAME="navigablechildren">NavigableChildren</A></H3>
<P>Similar to AccessibleChildren, but uses accNavigate instead.  
Rule of thumb:  Use AccessibleChildren unless it obviously is missing
the children; in that case try NavigableChildren.</P>
<PRE>
 my @ch = $menu-&gt;NavigableChildren();</PRE>
<P>
<H3><A NAME="get_accparent">get_accParent</A></H3>
<PRE>
 $p = $accObj-&gt;get_accParent();</PRE>
<P>Returns the parent object.  Returns undef if the object has no parent.</P>
<P>
<H3><A NAME="get_accstate">get_accState</A></H3>
<PRE>
 $state = $accObj-&gt;get_accState();</PRE>
<P>Returns a number composed of bits defined by the Active Accessibility STATE_ constants
(STATE_SYSTEM_NORMAL, etc.).  See <A HREF="#getstatetext">GetStateText</A> and &lt;``GetStateTextComposite''&gt;.</P>
<P>Returns undef if the object doesn't have this property.</P>
<P>
<H3><A NAME="get_accvalue">get_accValue</A></H3>
<P>Returns the 'value' of the accessible object:  the stuff in an editable 
text control, the outline-level of an outline item, etc.</P>
<PRE>
 $value = $accObj-&gt;get_accValue();</PRE>
<P>Returns undef if the object doesn't have this property.</P>
<P>
<H3><A NAME="acclocation">accLocation</A></H3>
<PRE>
 my ($left, $top, $width, $height) = $accObj-&gt;accLocation();</PRE>
<P>Returns the accessible object's location on the screen, in pixels.  (0,0) is
at the top left.  Dies if the object doesn't have this property.</P>
<P>
<H3><A NAME="accnavigate">accNavigate</A></H3>
<PRE>
 my $smch = $accObj-&gt;accNavigate(Win32::ActAcc::NAVDIR_FIRSTCHILD());
 while (defined($smch))
 {
        my $n = $smch-&gt;get_accName();
        print STDERR &quot;$n\n&quot;;
        $smch = $smch-&gt;accNavigate(Win32::ActAcc::NAVDIR_NEXT());
 }</PRE>
<P>Returns an Accessible Object representing one of the base object's relations.  
Win32::ActAcc defines the family of NAVDIR constants from OleAcc.h.
See <A HREF="#navdir constants">NAVDIR constants</A>.</P>
<P>accNavigate does not move focus, nor perform any other action on behalf of the user.</P>
<P>
<H3><A NAME="get_accdescription">get_accDescription</A></H3>
<PRE>
 $desc = $accObj-&gt;get_accDescription();</PRE>
<P>Returns undef if the object doesn't have this property.
If you're trying to debug your script, <A HREF="#describe">describe</A> is probably more appropriate,
since it appears most accessible objects don't define their description.</P>
<P>
<H3><A NAME="get_acchelp">get_accHelp</A></H3>
<PRE>
 $help = $accObj-&gt;get_accHelp();</PRE>
<P>Returns undef if the object doesn't have this property.</P>
<P>
<H3><A NAME="get_accdefaultaction">get_accDefaultAction</A></H3>
<PRE>
 $da = $accObj-&gt;get_accDefaultAction();</PRE>
<P>Returns undef if the object doesn't have this property.</P>
<P>
<H3><A NAME="get_acckeyboardshortcut">get_accKeyboardShortcut</A></H3>
<PRE>
 $ks = $accObj-&gt;get_accKeyboardShortcut();</PRE>
<P>Returns undef if the object doesn't have this property.</P>
<P>
<H3><A NAME="get_accchildcount">get_accChildCount</A></H3>
<PRE>
 $nch = $accObj-&gt;get_accChildCount();</PRE>
<P>See <A HREF="#accessiblechildren">AccessibleChildren</A>.</P>
<P>
<H3><A NAME="get_accchild">get_accChild</A></H3>
<PRE>
 $ch = $accObj-&gt;get_accChild(3);</PRE>
<P>See <A HREF="#accessiblechildren">AccessibleChildren</A>.</P>
<P>
<H3><A NAME="get_accfocus">get_accFocus</A></H3>
<PRE>
 $f = $accObj-&gt;get_accFocus();</PRE>
<P>
<H3><A NAME="accdodefaultaction">accDoDefaultAction</A></H3>
<PRE>
 $accObj-&gt;accDoDefaultAction();</PRE>
<P>Active Accessibility weirdness note:  Sometimes doesn't do anything.</P>
<P>
<H3><A NAME="get_itemid">get_itemID</A></H3>
<PRE>
 $plusOrDot = (Win32::ActAcc::CHILDID_SELF() == $ch[$i]-&gt;get_itemID()) ? '+' : '.';</PRE>
<P><CODE>get_itemID()</CODE> returns the item-ID that is part of the identity of the 
accessible object.</P>
<P>
<H3><A NAME="accselect">accSelect</A></H3>
<PRE>
 $accObj-&gt;accSelect(Win32::ActAcc::SELFLAG_TAKEFOCUS());</PRE>
<P>See <A HREF="#selflag constants">SELFLAG constants</A>.</P>
<P>
<H3><A NAME="click">click</A></H3>
<PRE>
 $accObj-&gt;click(\$eh);</PRE>
<P><CODE>click()</CODE> ``clicks'' the center of the accessible object, but first, it
activates the optional event monitor, so you can capture the consequences
of the click.  See <A HREF="#activate">activate</A> and <A HREF="#menupick">menuPick</A>.</P>
<P>
<H3><A NAME="finddescendant">findDescendant</A></H3>
<P>Applies a code-ref or regexp to each child, grand-child, etc.  
In scalar context, returns the first
Accessible Object for which the code-ref returns a true value,
or for which the regexp indicates a match.  In array context, returns 
a list of all matching Accessible Objects.</P>
<PRE>
 $btnClose = $wNotepadApp-&gt;findDescendant( 
        sub{    
                my $n = $_-&gt;get_accName(); 
                (defined($n) &amp;&amp; $n eq &quot;Close&quot;) &amp;&amp; 
                        ($_-&gt;get_accRole() == Win32::ActAcc::ROLE_SYSTEM_PUSHBUTTON()) 
        });</PRE>
<P>
<H3><A NAME="release">Release</A></H3>
<PRE>
 $accObj-&gt;Release();</PRE>
<P>Accessible objects are COM objects, so each one must
be Released when you're done with it.  
Perl's garbage collector and Win32::ActAcc::AO 
conspire to automatically Release the accessible objects, so you should not 
need to call Release in your scripts.</P>
<P>
<H2><A NAME="winevents">WinEvents</A></H2>
<P>WinEvents allow a script to keep apprised of windows appearing, disappearing, moving around, and
so forth; and thereby to react to the consequences of an action.</P>
<P>For example, the
script can press Start and then, by watching the event stream, latch onto the menu that comes up.</P>
<P>To watch the event stream, call <CODE>createEventMonitor()</CODE> and then use the 
EventMonitor's <CODE>waitForEvent()</CODE> or <CODE>getEvent()</CODE> method.  Refer to the aaEvents sample.</P>
<P>See also <A HREF="#event details">Event Details</A>.</P>
<P>
<H3><A NAME="createeventmonitor">createEventMonitor</A></H3>
<PRE>
 my $ehDlg = createEventMonitor(1);</PRE>
<P>createEventMonitor creates a Win32::ActAcc::EventMonitor object,
which the script can poll for WinEvents using <CODE>waitForEvent()</CODE> or getEvent().</P>
<P>The ``1'' means the EventMonitor is immediately activated.  Otherwise
the EventMonitor is latent until activated, which typically happens in
one of two ways:</P>
<UL>
<LI>
you call <A HREF="#activate">activate</A>.
<P></P>
<LI>
you call a method (like click or <A HREF="#menupick">menuPick</A>) that activates the monitor so you
can capture the results of the click.
<P></P></UL>
<P>
<H3><A NAME="eventmonitor">EventMonitor</A></H3>
<P>Here are the methods on the EventMonitor object you get from createEventMonitor.</P>
<P>
<H4><A NAME="waitforevent">waitForEvent</A></H4>
<P>Sometimes, you want to see <EM>whether</EM> something happens.  Other times, you <EM>know</EM>
what will happen, but you want to find out which Accessible Object it happens to.
<CODE>waitForEvent()</CODE> meets both needs.</P>
<P>Here's a sample of how to wait (for up to 30 seconds) for a Notepad window to appear.</P>
<PRE>
 $aoNotepad = $eh-&gt;waitForEvent(
  +{ 'event'=&gt;Win32::ActAcc::EVENT_OBJECT_SHOW(),
     'name'=&gt;qr/Notepad/,
     'role'=&gt;Win32::ActAcc::ROLE_SYSTEM_WINDOW() }, 30);</PRE>
<P>waitForEvent blocks the script until a matching event arrives, or the
timeout expires.  The return value is the accessible object of the
winning event, or undef if the timeout expired.  So: You see how the
sample cunningly not only learns <EM>that</EM> a Notepad windows has
appeared, but actually gets its Accessible Object for later use (such
as to <EM>close</EM> the window).</P>
<P>You can omit the timeout, in which case waitForEvent waits for a
matching event, which might mean waiting a very long time indeed.</P>
<P>The hash's entries are:</P>
<UL>
<LI>
<STRONG>event</STRONG>:  an event constant <EM>(remember the parentheses--see sample above)</EM>.  See <A HREF="#event constants">EVENT Constants</A>.
<P></P>
<LI>
<STRONG>name</STRONG> (optional): a regexp or string to match the name of the
accessible object of the event.  If it's a string, it must match
exactly--case matters and it must match the entire name.
<P></P>
<LI>
<STRONG>role</STRONG> (optional):  a role constant that must match the accessible object of the event, e.g., Win32::ActAcc::ROLE_SYSTEM_WINDOW().  See <A HREF="#role constants">ROLE Constants</A>.
<P></P></UL>
<P>If your desires don't fit the hash mold, you can give a code-reference
instead.  waitForEvent returns when the code returns any non-undef.
waitForEvent returns what the code returned.</P>
<PRE>
 $eh-&gt;waitForEvent(sub{print Win32::ActAcc::Event::evDescribe(@_).&quot;\n&quot;;undef}, $secs);</PRE>
<P>
<H4><A NAME="getevent">getEvent</A></H4>
<P>You will usually want to use waitForEvent.  But, just in case, there <EM>is</EM> a way to 
retrieve one event at a time.</P>
<P>getEvent retrieves an event from the event monitor, or undef if no event is ready.</P>
<P>The event is a blessed hash (<A HREF="#win32::actacc::event">Win32::ActAcc::Event</A>).</P>
<P>
<H4><A NAME="clear">clear</A></H4>
<PRE>
 $eh-&gt;clear();</PRE>
<P>Erases the backlog of events on the event monitor.</P>
<P>
<H4><A NAME="synch">synch</A></H4>
<P><CODE>synch()</CODE> lets you bookmark an EventMonitor and return later to the bookmarked point.</P>
<PRE>
 $eh1-&gt;synch($eh2);</PRE>
<P>``Synchronizes'' $eh1 with $eh2 by setting $eh1's event-buffer cursor to $eh2's, 
so that $eh1-&gt;<CODE>getEvent()</CODE> will
return the same event as $eh2-&gt;getEvent().  <CODE>synch()</CODE> can move the monitor forward or backward;
in other words, it can both advance and rewind.  (But, when rewinding, watch out for 
buffer overrun. The spot you rewind to, may have been re-used since the time the event
was written that you think you are rewinding to.)</P>
<P>
<H4><A NAME="isactive">isActive</A></H4>
<PRE>
 $a = $eh-&gt;isActive();</PRE>
<P>Returns a true value if the event monitor is active, a false
value if it is latent.</P>
<P>
<H4><A NAME="activate">activate</A></H4>
<PRE>
 $eh-&gt;activate(1); # activate
 $eh-&gt;activate(0); # deactivate</PRE>
<P>Activating a monitor makes it ``catch up'' with all events received so far,
and makes it sensitive to future events.  Activating an already-active
monitor has no effect on it.</P>
<P>Deactivating a monitor makes it useless, until it is reactivated.</P>
<P>
<H4><A NAME="geteventcount">getEventCount</A></H4>
<PRE>
 my $ec = $eh-&gt;getEventCount();</PRE>
<P>Returns a cumulative total number of events caught by the 
event hook installed by Win32::ActAcc.  (All EventMonitor objects
feed from this same event hook.)</P>
<P>
<H4><A NAME="debug_spin">debug_spin</A></H4>
<P>This debug function displays the EventMonitor's events for a certain number of seconds.</P>
<PRE>
 $eh-&gt;debug_spin(60);</PRE>
<P>
<H3><A NAME="win32::actacc::event">Win32::ActAcc::Event</A></H3>
<P>An event is an object of type Win32::ActAcc::Event.  It's a hash with fields
as described in the API documentation:</P>
<PRE>
 event
 hwnd
 idObject
 idChild
 dwmsEventTime</PRE>
<PRE>
 $e = $eh-&gt;getEvent();
 print $$e{'event'} . &quot;\n&quot;;</PRE>
<P>``Event'' is a constant (see <A HREF="#event constants">EVENT Constants</A>).  You can test it like this:</P>
<PRE>
 next unless Win32::ActAcc::EVENT_OBJECT_VALUECHANGE()==$$e{'event'};</PRE>
<P>
<H4><A NAME="getao">getAO</A></H4>
<PRE>
 $accObj = $e-&gt;getAO();</PRE>
<P>Returns the accessible object that the event pertains to.</P>
<P>Active Accessibility weirdness note:  
getAO sometimes dies with an access-violation error.  
You may want to put your calls to getAO into an eval.</P>
<P>
<H4><A NAME="evdescribe">evDescribe</A></H4>
<PRE>
 print $e-&gt;evDescribe() . &quot;\n&quot;;</PRE>
<P>Good for debugging - returns some information about the event.</P>
<P>
<H3><A NAME="eventconstantname">EventConstantName</A></H3>
<P>Returns the C constant name for a WinEvent number defined in WinAble.h.
See <A HREF="#event constants">EVENT Constants</A>.</P>
<P>
<H3><A NAME="accessibleobjectfromevent">AccessibleObjectFromEvent</A></H3>
<P>Obtain an ``accessible object'' from information in a WinEvent.  
(You may prefer to use the object-oriented $e-&gt;<A HREF="#getao">getAO</A>() way instead.)</P>
<PRE>
 my $accObj = AccessibleObjectFromEvent($$e{'hwnd'}, $$e{'idObject'}, $$e{'idChild'});</PRE>
<P>
<H3><A NAME="event details">Event Details</A></H3>
<P>Each Perl process with an active EventMonitor installs an Active
Accessibility ``in-proc'' event hook that records all events in a
fixed-size circular buffer.</P>
<P>All of the script's EventMonitor objects cursor through the process' lone
circular buffer.</P>
<P>You will want to tightly bracket the
scope of your EventMonitor objects (or deactivate them 
as soon as they are no longer interesting) since the event hook slows down
your computer slightly and it's a pity to leave an event hook going when you 
don't need it.</P>
<P>There's no overrun indicator on the circular
buffer, so try to keep your EventMonitors reasonably up-to-date lest
you miss an event.</P>
<P>EventMonitors don't seem to pick up any WinEvents from <EM>Command Prompt</EM>
windows in Windows 2000.  Perhaps these windows are owned by a process that resists
in-proc event hooks.  Hmm.</P>
<P>Circular buffer size (in events) for this build of ActAcc:</P>
<font face="Arial Narrow" size="-1"><P>5000</P>
</font><P>
<H2><A NAME="tools">Tools</A></H2>
<P>
<H3><A NAME="aadigger.pl">aaDigger.pl</A></H3>
<P>aaDigger lets you navigate the hierarchy of accessible objects, 
rooted at the Desktop window.  aaDigger has its own <A HREF="././aaDigger.html">manpage</A>.</P>
<P>When you're planning an Active Accessibility script, aaDigger helps you get your feet
on the ground.</P>
<P>
<H3><A NAME="aaevents.pl">aaEvents.pl</A></H3>
<P>aaEvents makes a continuous display of your system's WinEvents.  
When you're casting about for clues about which event your
script should be keying to a real-world occurrence, aaEvents 
can help you make up your mind.</P>
<P>
<H3><A NAME="aawhereami.pl">aaWhereAmI.pl</A></H3>
<P>aaWhereAmI continuously describes the accessible object under the cursor at any
given moment.</P>
<P>Active Accessibility weirdness note:  Not all accessible objects have
a place in the hierarchy that has Desktop at its root.</P>
<P>
<HR>
<H1><A NAME="bugs, limitations, and shortcomings">BUGS, LIMITATIONS, AND SHORTCOMINGS</A></H1>
<P>You can't use an ``accessible object'' with Win32::OLE.  Especially with
Microsoft Office, it would be nice to get a ``native object model''
IDispatch* from AccessibleObjectFromWindow, and hand it off to
Win32::OLE to make Office-specific OLE Automation method calls.</P>
<P>There's no overrun indicator on an EventMonitor.  You can't tell it to ignore
mouse-move events - not even redundant or superseded ones.</P>
<P>Win32::ActAcc probably doesn't work multi-threaded.</P>
<P><CODE>nav()</CODE> and <CODE>findDescendant()</CODE> should accept the same path arguments.  
And the path notation should provide a dizzying combination of XPath and
regular-expression features.  (For XPath, see <A HREF="http://www.w3.org/TR/xpath">http://www.w3.org/TR/xpath</A>.)</P>
<P>EventMonitors install only in-proc hooks.  Maybe that's why they don't
pick up any events from Command Prompt windows.</P>
<P>Win32::ActAcc doesn't do Unicode.  If you run aaDigger.pl and point it
to the Russian version of Windows Media Player, the text all comes
back as question marks.</P>
<P>
<HR>
<H1><A NAME="installation">INSTALLATION</A></H1>
<P>
<H2><A NAME="installation from source code">Installation from source code</A></H2>
<PRE>
 perl makefile.pl
 nmake 
 nmake install
 nmake test</PRE>
<P>Yes, you have to install it before you test it.  Otherwise it can't
find its DLL.  Probably someone will figure out how to fix this.</P>
<P>Prerequisites:</P>
<UL>
<LI>
You may need Visual C++ 6.0 SP 4.  The C/C++ part of Win32::ActAcc might not
be portable to other compilers.
<P></P>
<LI>
You need the July 2000 ``Platform SDK''.  
Earlier versions of the Active Accessibility SDK could give problems compiling.
<P></P>
<LI>
The test suite requires Notepad.exe on the path.  Also, it requires
Win32::GuiTest.
<P></P>
<LI>
The Eliza-AOLInstantMessenger sample requires up-to-date HTML parsing
modules.  It will tell you if yours are missing or out-of-date.
<P></P></UL>
<P>
<H2><A NAME="installation for activeperl users (ppm)">Installation for ActivePerl users (PPM)</A></H2>
<P>ActivePerl users can install Win32::ActAcc using PPM.</P>
<OL>
<LI>
Unzip the zip (Win32-ActAcc-n.n.zip).  Make sure your unzip
program preserved the directory tree: for example, you should see
Win32-ActAcc.tar.gz in an ``x86'' subdirectory under the directory that
contains ActAcc.html (the documentation).
<P></P>
<LI>
Open a command prompt window.
<P></P>
<LI>
In the command prompt, ``cd'' to the directory that contains ActAcc.html.
<P></P>
<LI>
In the command prompt, issue the following command.
<PRE>
 ppm install --location=. Win32-ActAcc</PRE>
<P></P></OL>
<P>To check the installation, you may try aaDigger.pl.  The test suite
(nmake test) doesn't seem to work if you do the ppm installation.</P>
<P>
<H2><A NAME="files installed">Files Installed</A></H2>
<UL>
<LI>
In bin:  aaDigger.bat and aaDigger.pl, aaEvents.bat and aaEvents.pl, 
aaWhereAmI.bat and aaWhereAmI.pl
<P></P>
<LI>
In site\lib\Win32:  aaDigger.pl, aaEvents.pl, aaWhereAmI.pl, ActAcc.pm, ActAcc.pod
<P></P>
<LI>
In site\lib\auto\Win32\ActAcc:  ActAcc.dll, ActAccEM.dll
<P></P></UL>
<P>
<HR>
<H1><A NAME="copyright">COPYRIGHT</A></H1>
<P>Copyright 2001, Phill Wolf.</P>
<P>You may use Win32::ActAcc under the terms of the Artistic License, as
specified in the README file of the Perl distribution.</P>
<P>
<HR>
<H1><A NAME="author">AUTHOR</A></H1>
<P>Phill Wolf, <A HREF="mailto:pbwolf@cpan.org">pbwolf@cpan.org</A></P>
<P>
<HR>
<H1><A NAME="see also">SEE ALSO</A></H1>
<P>Active Accessibility documentation.  As of this writing, it is available on 
<A HREF="http://msdn.microsoft.com">http://msdn.microsoft.com</A> on the ``Libraries'' page:</P>
<PRE>
 Platform SDK
  User Interface Services
   Accessibility
    Microsoft Active Accessibility</PRE>
<P>Win32::OLE</P>
<P>Win32::GuiTest</P>

</BODY>

</HTML>
